### 存储

#### 磁盘读写时间的计算

- 先寻道：磁头移动到正确的磁道上方。
- 再旋转：磁头到了正确的磁道上，这个时候旋转才有用
- 最后传输。

#### 提高访问速度的方式

- 降低IO次数
- 降低排队等待时间
- 降低寻道时间
  - 磁盘块连续存储
  - 多柱面并行存储（因为一次读取能把各盘面上的当前扇区都拿到）（对于老式磁盘，是这种情况）
  - RAID多体交叉思想

#### RAID

- 多体交叉拆分算法
  - 不同的拆分算法可以实现不同的并行方式。
  - 比特级拆分：对字节进行拆分，把一个字节拆成8个bit，每个bit分别存在不同的并行磁盘上
  - 块级拆分：对文件进行拆分，把文件的不同块存在不同的并行磁盘上。
- RAID0
  - 没有冗余，只实现并行存取
- RAID1
  - 完全冗余，直接镜像一份
  - 例如原来需要4块磁盘，那我再加4块，把内容复制一遍
- RAID2
  - 基于**比特级**拆分。
  - 采用4-3码（海明码）校验。因此，磁盘的分配比例是4数据：3校验。
- RAID3
  - 采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中（Wikipedia）
- RAID4
  - 基于**块级**拆分。其他同RAID3.
- RAID5
  - 基于**块级**拆分。
  - 在RAID4的基础上，使5个盘互位校验盘，解决了RAID4中，校验盘成为性能瓶颈的问题（且磨损严重）。

#### DBMS索引和Inode表的关系

- DBMS可以利用OS的FAT表先占用一些磁盘块。然后，就可以使用自己的索引去**更加高效**地管理这些磁盘快了。

- 索引能给出表项**具体在**哪个磁盘块上。

  > 区别：OS给出的是文件在哪个块上，DBMS给出的是表在哪个块上。

#### 三级结构，两层交互

- 磁盘
  - 存储数据库的真正数据
- 内存（缓冲区）
  - 存储当前需要进行交互的数据。必须把磁盘中的块读入内存（我们认为磁盘快和内存页是一样大的），CPU才能处理。
  - 负责协调内存空间和磁盘之间关系的，是**缓冲区**。
  - 缓冲区**掌握**了内存页和磁盘块的映射索引，实现与磁盘的交互（读入写回）。
  - 缓冲区还**掌握**了记录和其所在页的映射索引，实现与DBMS的交互（数据缓冲）。
- DBMS
  - DBMS**掌握**了一套索引。内容是哪个记录在哪个磁盘块上（实现宏观上的与磁盘的交互。但是，实际上中间通过缓冲区实现具体IO细节，但是对DBMS来说，它可以实现直接根据自己的索引表去访问磁盘块上的记录）。
- DBMS和磁盘通过缓冲区交互的过程
  - DBMS需要访问一个块，缓冲区读入这个块到内存，建立记录和内存中指针（页）的索引（这是给DBMS看的），建立该页和磁盘快的索引（这是给磁盘看的），牵线搭桥，完成了任务。

#### 数据存储与查询实现

- 自底向上，DBMS的存储查询实现是：
- 存储管理器
  - 处于系统最底层，负责控制磁盘读写，对上层提供块读写接口
- 缓冲区管理器
  - 负责管理内存缓冲区，控制内存分配
  - 实现DBMS和外部存储器之间的通信
- 索引文件记录管理器
  - 负责管理DB的三块信息：操作计划、数据模式、数据控制信息。
  - 这三块信息分别由DML引擎、DDL引擎、DCL引擎操作和控制。
- 三个引擎
  - DML引擎、DDL引擎、DCL引擎分别接受经DML编译器、DDL编译器、DCL编译器编译得到的执行序列，进行实际操作。
  - **各种操作的实际实现是经过了“三级结构，两层交互”。**
- 三个编译器
  - DML编译器、DDL编译器、DCL编译器负责接受用户输入的DML、DDL、DCL命令并编译，供引擎来执行。
  - 特别地，DML编译器会把算法库中的各种算法进行选择性组合，给出调用顺序，生成查询计划。该查询计划可以传递给DML引擎。DML引擎执行计划的时候，还会再去调用算法库，实现查询操作。

#### 记录的存储

- 定长和变长
  - 定长存储
    - 可以直接根据长度偏移量得出这是哪条记录
  - 变长存储
    - 按指针定位
    - 按定界符（开始结束标志）定位
- 跨块和非跨块
  - 跨块存储
    - 如果这个块剩下的空间不够存一条记录，那就能存多长存多长，然后从下一块开始处继续存。中间用指针链接。
    - 问题：块之间有关联，对这些块**难以并行**操作
  - 非跨块存储
    - 空着。
- 块分配方式
  - 连续分配
    - 存在扩展问题，但是速度快
  - 链接分配
    - 速度慢
  - 按Segment分配
    - Segment是若干连续磁盘块。不同Segments之间可以用指针链接
    - 这是前两种方法的折中，兼顾了二者优点
  - 索引分配
    - 类似FAT

#### 文件组织

- 无序记录文件（堆文件）
  - 每次来了新记录都加在尾部
  - 删除记录只需要标记一下，然后来新记录可以优先从这里面找（但是可能因为前后记录大小不同造成内碎片）
  - 数据库重组：压缩内碎片，提升效率
- 有序记录文件（排序文件）
  - 查找效率高，可以折半搜索
  - 用于排序的字段称为排序字段、排序码
  - 插入慢
  - 可以引入“overflow表”来给插入提速，overflow表类似于一个堆文件。可以预见，当overflow表很大时，有序记录文件的查询效率向堆文件靠拢。
  - 数据库重组：把overflow表并入排序文件。
- 散列文件
  - 一般情况下一个桶对应一个块。通过表的某字段计算其散列，得到对应的桶。用于计算的这个字段和上面一种方法类似，称为散列字段、散列码。
  - 如果发生哈希碰撞，桶就对应不止一个块了。这个时候每个桶可以看做一个小的堆文件。
  - 桶是有大小的。如果碰撞过于离谱，可以使用overflow桶。即：在桶的尾部加一个指针，连接到新桶，从而扩容。通过这种方式，可以无限扩容一个桶。
- 聚簇文件
  - 把某一字段的值相同或相似的记录尽量放在连续的块。
  - 如果几个表相互关联，把他们按“相似”处理，可以对多表查询的情况进行提速。

#### Oracle数据库结构

- 逻辑存储层
  - 表空间：是整个数据库的顶级结构。数据库本身有一个系统表空间（SYSTEM），存储数据库各项信息。用户可以创建表空间，并自己命名。
    - 表空间即表的存放空间。一个表空间可以有多个表。
  - 操作系统文件：一个表空间可以由一个或多个操作系统文件**构成**。但是一个操作系统文件只能与一个数据库相连，显然这是一个单向的一对多的关系。
    - 因为多个文件构成一个表空间，所以操作往往是跨文件的。
    - 操作系统文件的作用只是用于占位，以保证OS和DBMS的一致性。这个可以类比Windows下的Pagefile。文件把这块空间划定了，这块空间就归DBMS管了。DBMS直接从OS处接管这块空间的存取控制。
    - 表和文件之间没有对应关系。一个表可以存放在多个文件中。（文件只是起到占位作用。实际怎么存还是看在哪些块上。）
- 物理存储层
  - 物理存储层是逻辑存储层的直接下层。为其提供存储服务。
  - 段：分配了一段特定数据结构的盘区。
    - 分为数据段、索引段、临时段
    - 段和表之间没有数量上的对应关系。可以是任意对任意的。
  - 盘区：特定数量的连续数据块。该“特定数量”可以需求视情况由DBMS管理员动态调整。
    - 按盘区访问数据库，盘区大小很关键。如果数据库很大，显然大盘区访问会更容易找到目标。
  - 数据块
    - 是最小的IO单位。

### 事务概述

#### 事务的定义

- 数据库提供的**控制数据操作的手段**。通过该手段，程序可以把一系列一系列操作作为**一个整体**进行操作和控制，并能够保证**一致性的状态转换**。
- 从程序员的角度，一系列SQL语句的**整体执行**就可以看作一个事务。
  - 由程序员提出，并开始执行；在结束时，可以提交`commit`或**撤销**`rollback`。
- 事务以开始执行SQL语句为开始标志，以`commit`或`rollback`为结束标志，**不一定**非要有`begin transaction`或`end transaction`。
  - 有多少次`commit`或`rollback`，就产生多少个事务。
- **具有ACID特性的操作称为事务。**

#### 为什么需要事务的并发控制

- 多个事务可以并发执行。如果不加以管理，会导致数据的不一致性。
- 在事务并发时，通过对SQL语句操作的顺序进行合理安排，来保证事务宏观的独立性、完整性、正确性，就是事务的并发控制。
- 三种典型的不一致错误：损失修改、不能重复读、脏读

#### 事务的特性：ACID

- `Atomicity`原子性
  - 事务包含的操作要么都不做，要么一次性都做完。
- `Consistency`一致性
  - 保证在事务并发过程中，仍保证数据的一致性（即不能出现上述三种不一致性错误）
- `Isolation`隔离性
  - 事务在并发的过程中仍然要保持独立。互相不能影响结果。
  - 例如就算是T1、T2两个事务并发执行、**其结果应当等效于**先T1、后T2，或先T2、后T1.
- `Durability`持久性
  - 持久性包含两个方面：
  - 保证提交是持久的。已提交的数据应当写在了磁盘上，不应丢失。
  - 被撤销事务的影响是可恢复的。

#### 重新定义事务

> 具有ACID特性的操作称为事务。

#### 事务管理器

- 当应用程序进行SQL操作，事务管理器负责`产生`一个新的事务，并打`时间戳`。
- 事务的后续的`操作`由事务管理器产生、管理。

#### 事务调度器

- 对当前存在的所有事务的操作产生一个合理的操作序列。
- 目标：保证一致性。

### 事务调度与可串行性

#### 事务调度

- `事务的基本步`即事务的基本操作，包括读、写、控制操作（例如加锁、解锁）
  - 事务的基本步可以**类比OS中进程调度的机器指令。**
- `事务调度`即事务的各基本步的一个合理的**执行顺序**。

#### 串行调度和并发调度

- 串行调度：例如当前有T1、T2都要执行，那我真的就是让T1先跑，跑完了才轮到T2.即：先依次执行T1的基本步，然后是T2的。
- 并发调度：例如T1的基本步和T2的基本步是交错执行的。**就算只有一个基本步交错执行了，我们也称为是并发调度。**
  - 当且仅当T1、T2两个事务并发调度，**其结果应当等效于**先T1、后T2，或先T2、后T1，才说明这个并发调度是`正确的`。

#### 可串行性（可串行化）

- 可串行性是用来`衡量`并发调度`正确性`的一个概念。即：不管当前数据库状态如何，这个调度对数据库的影响和某个串行调度`相同`，则说明这个调度是可串行化的，或具有可串行性。
- 当T1、T2两个事务并发调度，**其结果确实等效于**先T1、后T2，或先T2、后T1，那就是说这是个**可串行化的并发调度了**。

#### 充分不必要

> 可串行化调度一定是正确的并行调度，但是正确的并行调度不一定可串行化。

可串行化调度是并行调度的`子集`。

#### 等效串行序列

- 可串行化的并发调度的等效串行序列`不唯一`。
- 例如上面说的既可以等效为T1再T2，也可以是T2再T1.

#### 表达模型

$r_T(A)$表示事务T读A元素。 $w_T(A)$表示事务T写A元素。这两个操作属于基本操作（基本步）。

#### 冲突

- 冲突的定义
  - 调度中的一对连续的动作，如果他们俩`调换顺序`，那么所涉及的事务中至少一个的`行为发生改变`。
- 如果两个操作有`冲突`，那么他们`不能交换次序`。否则，可以交换。
- 常见冲突
  - `同一事务`内相邻的两个基本步肯定冲突。否则就改变了编写这个事务的本意。
  - `不同事务`对同一元素的紧挨着的`写`操作是冲突的。
  - `不同事务`对同一元素的紧挨着的`一读一写`操作是冲突的。

#### 冲突可串行性（冲突可串行化）

- 如果一个调度，通过交换两个`相邻的`无冲突操作可以转换到（**注意不是等效，而是真的转换得到**）某串行调度，那么这个调度是冲突可串行化的。
  - 一般需要一系列交换才能达到目标。

> 冲突可串行性调度是可串行性调度的子集。

- 冲突可串行性的作用：因为不能直接判断并发调度的正确性，不能直接判断可串行性调度，但是我们可以判断是否具有冲突可串行性。如果具有冲突可串行性，由于包含关系，则我们就判断出了它具有可串行性，也就是说该并发调度是正确的。

> 因此，冲突可串行性调度是判断某并发调度是否正确的方法。

- 判断是否是冲突可串行化的一般方法：例如基本步序列 $r_2(A);r_1(B);w_2(A);r_2(B);r_3(A);w_1(B);w_3(A);w_2(B)$ ，这里有三个事务 $T_1,T_2,T_3$ ，可以画一个图，其中节点有1、2、3号分别代表这三个事务。观察基本步序列，可以看到$w_2(A);r_3(A)$、$r_2(B);w_1(B)$、$w_1(B);w_2(B)$ 是三对冲突基本步，他们不能交换顺序，也就是说必须保证他们的顺序，**也就是说他们直接确定了这三个事务的相对顺序必须满足的条件**。根据此，画前驱图：如果事务 $T_1$ 必须在 $T_2$ 之前完成，那么就有一条从1号点指向2号点的边。由此画图，如果最终的图没有环，这就是一个冲突可串行化的调度，且最终的串行化调度顺序就是这个图的`拓扑序列`。否则如果有环，这就不是一个冲突可串行化调度。可以看出这里在1、2点之间有环，所以~。

### 基于锁的并发控制

#### 并发控制的基本方法（如何产生一个冲突可串行化调度？）

- 基于封锁的并发控制（本节）
- 基于时间戳的并发控制
- 基于有效性确认的并发控制
- 基于封锁的控制是`基于锁的`方法；基于时间戳、有效性的属于`基于撤回的`方法。

#### 锁

- 锁是控制并发的手段
- 每一个数据元素都有自己的锁
- 每一事务读写数据元素前，要获得`该元素持有的锁`；读写完毕后，要`释放`锁
  - 如果其他事务已经获得该锁，那么当前事务需要`进入等待`

> 元素的锁可以理解为该元素有一个初始值是1的**信号量**。事务相当于是进程。加锁是P，解锁是V。因为信号量初始值是1，所以如果该锁已经被其他事务拿走，新来的事务进入等待。

#### 操作表达模型

$L_i(A)$表示事务i对元素A加锁； $U_i(A)$表示事务i对元素A解锁。这两个操作和前面提到的读、写一样都属于基本操作（基本步）。

#### 锁表

- 锁表中存储了当前各锁的情况。
- 字段一般是`元素-事务-类型`。
  - 表示哪个事务对哪个元素加了锁；或是哪个事务对哪个元素加了什么类型的锁。

