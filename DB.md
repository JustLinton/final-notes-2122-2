### 磁盘

#### 磁盘读写时间的计算

- 先寻道：磁头移动到正确的磁道上方。
- 再旋转：磁头到了正确的磁道上，这个时候旋转才有用
- 最后传输。

#### 提高访问速度的方式

- 降低IO次数
- 降低排队等待时间
- 降低寻道时间
  - 磁盘块连续存储
  - 多柱面并行存储（因为一次读取能把各盘面上的当前扇区都拿到）（对于老式磁盘，是这种情况）
  - RAID多体交叉思想

#### RAID

- 多体交叉拆分算法
  - 不同的拆分算法可以实现不同的并行方式。
  - 比特级拆分：对字节进行拆分，把一个字节拆成8个bit，每个bit分别存在不同的并行磁盘上
  - 块级拆分：对文件进行拆分，把文件的不同块存在不同的并行磁盘上。
- RAID0
  - 没有冗余，只实现并行存取
- RAID1
  - 完全冗余，直接镜像一份
  - 例如原来需要4块磁盘，那我再加4块，把内容复制一遍
- RAID2
  - 基于**比特级**拆分。
  - 采用4-3码（海明码）校验。因此，磁盘的分配比例是4数据：3校验。
- RAID3
  - 采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中（Wikipedia）
- RAID4
  - 基于**块级**拆分。其他同RAID3.
- RAID5
  - 基于**块级**拆分。
  - 在RAID4的基础上，使5个盘互位校验盘，解决了RAID4中，校验盘成为性能瓶颈的问题（且磨损严重）。

#### DBMS索引和Inode表的关系

- DBMS可以利用OS的FAT表先占用一些磁盘块。然后，就可以使用自己的索引去**更加高效**地管理这些磁盘快了。

- 索引能给出表项**具体在**哪个磁盘块上。

  > 区别：OS给出的是文件在哪个块上，DBMS给出的是表在哪个块上。

#### 三级结构，两层交互

- 磁盘
  - 存储数据库的真正数据
- 内存（缓冲区）
  - 存储当前需要进行交互的数据。必须把磁盘中的块读入内存（我们认为磁盘快和内存页是一样大的），CPU才能处理。
  - 负责协调内存空间和磁盘之间关系的，是**缓冲区**。
  - 缓冲区**掌握**了内存页和磁盘块的映射索引，实现与磁盘的交互（读入写回）。
  - 缓冲区还**掌握**了记录和其所在页的映射索引，实现与DBMS的交互（数据缓冲）。
- DBMS
  - DBMS**掌握**了一套索引。内容是哪个记录在哪个磁盘块上（实现宏观上的与磁盘的交互。但是，实际上中间通过缓冲区实现具体IO细节，但是对DBMS来说，它可以实现直接根据自己的索引表去访问磁盘块上的记录）。
- DBMS和磁盘通过缓冲区交互的过程
  - DBMS需要访问一个块，缓冲区读入这个块到内存，建立记录和内存中指针（页）的索引（这是给DBMS看的），建立该页和磁盘快的索引（这是给磁盘看的），牵线搭桥，完成了任务。

#### 数据存储与查询实现

- 自底向上，DBMS的存储查询实现是：
- 存储管理器
  - 处于系统最底层，负责控制磁盘读写，对上层提供块读写接口
- 缓冲区管理器
  - 负责管理内存缓冲区，控制内存分配
  - 实现DBMS和外部存储器之间的通信
- 索引文件记录管理器
  - 负责管理DB的三块信息：操作计划、数据模式、数据控制信息。
  - 这三块信息分别由DML引擎、DDL引擎、DCL引擎操作和控制。
- 三个引擎
  - DML引擎、DDL引擎、DCL引擎分别接受经DML编译器、DDL编译器、DCL编译器编译得到的执行序列，进行实际操作。
  - **各种操作的实际实现是经过了“三级结构，两层交互”。**
- 三个编译器
  - DML编译器、DDL编译器、DCL编译器负责接受用户输入的DML、DDL、DCL命令并编译，供引擎来执行。
  - 特别地，DML编译器会把算法库中的各种算法进行选择性组合，给出调用顺序，生成查询计划。该查询计划可以传递给DML引擎。DML引擎执行计划的时候，还会再去调用算法库，实现查询操作。

#### 记录的存储

- 定长和变长
  - 定长存储
    - 可以直接根据长度偏移量得出这是哪条记录
  - 变长存储
    - 按指针定位
    - 按定界符（开始结束标志）定位
- 跨块和非跨块
  - 跨块存储
    - 如果这个块剩下的空间不够存一条记录，那就能存多长存多长，然后从下一块开始处继续存。中间用指针链接。
    - 问题：块之间有关联，对这些块**难以并行**操作
  - 非跨块存储
    - 空着。
- 块分配方式
  - 连续分配
    - 存在扩展问题，但是速度快
  - 链接分配
    - 速度慢
  - 按Segment分配
    - Segment是若干连续磁盘块。不同Segments之间可以用指针链接
    - 这是前两种方法的折中，兼顾了二者优点
  - 索引分配
    - 类似FAT

#### 文件组织

- 无序记录文件（堆文件）
  - 每次来了新记录都加在尾部
  - 删除记录只需要标记一下，然后来新记录可以优先从这里面找（但是可能因为前后记录大小不同造成内碎片）
  - 数据库重组：压缩内碎片，提升效率
- 有序记录文件（排序文件）
  - 查找效率高，可以折半搜索
  - 用于排序的字段称为排序字段、排序码
  - 插入慢
  - 可以引入“overflow表”来给插入提速，overflow表类似于一个堆文件。可以预见，当overflow表很大时，有序记录文件的查询效率向堆文件靠拢。
  - 数据库重组：把overflow表并入排序文件。
- 散列文件
  - 一般情况下一个桶对应一个块。通过表的某字段计算其散列，得到对应的桶。用于计算的这个字段和上面一种方法类似，称为散列字段、散列码。
  - 如果发生哈希碰撞，桶就对应不止一个块了。这个时候每个桶可以看做一个小的堆文件。
  - 桶是有大小的。如果碰撞过于离谱，可以使用overflow桶。即：在桶的尾部加一个指针，连接到新桶，从而扩容。通过这种方式，可以无限扩容一个桶。
- 聚簇文件
  - 把某一字段的值相同或相似的记录尽量放在连续的块。
  - 如果几个表相互关联，把他们按“相似”处理，可以对多表查询的情况进行提速。