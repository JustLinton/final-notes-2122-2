 

## 画线画圆

#### DDA

- 因为在迭代算法中，每一轮循环的结果都是在上一轮循环的基础上加一个增量得到的，所以称为增量算法。
- 约定屏幕空间是一个二维坐标系的第一象限。
- 如果待扫描转换的线的k>1，那么y增长的比较快，否则x增长的比较快。我们选择增长比较快的那个量，让他每次有1的增量，然后另一个增长比较慢的量的增量根据块的那个量的增量算出。例如x增长快，那么 $x_i=1,y_i=k$；如果y增长快，那么 $y_i=1,x_i=\frac{1}{k}$。
  - 为什么让增长快的那个的增量=1？因为这样就能保证在增长快的那个方向上，拥有连续变化的像素。（因为增长1只会跨越1个像素）。因为像素的长度是1.
  - 而且，如果让增长慢的那个是1，那么快的那个的增量就会>1，就会导致在它的方向上，像素不再连续，造成直线**断断续续**的情况。
- 缺点：存在浮点运算，慢。（舍入取整）
  - 如何对一个浮点数进行取整？ `(int)(x+0.5)`即可。

#### Bresenham

- 以 $0\leq k\leq 1$为例，此时根据DDA的思想，x是每次增量较大的那一个，所以取x为迭代器，每次+1.
- 设当前绘制了点 $(x_i,y_i)$ ，在+1的过程中，判断直线上的点 $F(x)$ 和两个候选点的中点 $(x_i+1,y_i+0.5)$的上下关系，如果 $F(x)$在中点的上方，则取点 $(x_i+1,y_i+1)（右上点）$，否则取 $(x_i+1,y_i)$（右边点）。
- 由直线方程，得到隐式方程 $y-kx-b=0$，而把点 $(x_i+1,y_i+0.5)$代入，如果隐式方程>0，则说明中点位于线下方；否则位于线上方，即可完成判断。
  - 即：观察判别式 $y_i+0.5-k(x_i+1)-b$的符号。
  - 设 $d=y_i+0.5-k(x_i+1)-b$.
- 改为递推（递增）
  - 需要根据上次画点的情况得到本次画点所需的误差项。
  - 如果上次画点 $(x_i,y_i)$，
    - 那么如果上次取下一个点为“右上”，那么本次的点的坐标实际上是 $(x_i+1,y_i+1)$，本次的中点就变成了 $(x_i+2,y_i+1.5)$，把 $(x_i+2,y_i+1.5)$代入隐式方程，整理得 $F(x_i+2,y_i+1.5)=d-k+1$，也就是本次画点需要得出新点的误差是d-k+1.
    - 如果上次取下一个点为“右”，那么本次的点的坐标实际上是  $(x_i+1,y_i)$，那么新点要参照的中点是 $(x_i+2,y_i+0.5)$，代入隐式方程，整理得 $F(x_i+2,y_i+0.5)=d-k$，也就是本次画点需要得出新点的误差是d-k.
  - 总结：如果上次画点右上，那么本次需要的误差是d-k**+1**否则是d-k（不用+1）。
  - d的初值是什么？将 $(x_0+1,y_0+0.5)$代入隐式方程，得 $F(x_0+1,y_0+0.5)=0.5-k$.也就是d应该取初值0.5-k。
- 摆脱浮点运算
  - 因为新d是老d-k+1，或老d-k，且d的初值是0.5-k，所以只需要把0.5和k这两个浮点数变成整数。因为我们只需要判断d的符号，所以任意乘一个倍数并不影响判断。因此乘2（消除0.5）再乘 $\Delta x$（消除k）。
  - 于是，把上述的算法中的d都乘 $2\Delta x$即可，其他不变（x还是每次都+1，y还是+0或+1，但是d的迭代变成了 $2d\Delta x-2\Delta y+ 2\Delta x$ 或 $2d\Delta x-2\Delta y$（也就是d的增量变成了原来的 $2\Delta x$倍。））

#### 改进Bresenham算法

- 仍然以 $0\leq k\leq 1$为例，此时根据DDA的思想，x是每次增量较大的那一个，所以取x为迭代器，每次+1.
- 设刚才画了点 $(x_i,y_i)$，根据Bresenham思想，现在的任务是确定x取 $(x_i+1)$时y的取值是否+1。引入简洁误差d，表示待画的线在 $x=x_i+1$处的y值和 $y_i$的差值，设为d。如果 $d>0.5$，则下一个y取 $y_i+1$，否则取 $y_i$。注意，如果取了 $y_i+1$，**那么需要让d再减去1。**
- 改为递推（递增）
  - 显然，每次迭代，d会增加k。因为交点一直都在待画的直线上。因此我们获得了其增量=k。
  - 初始值=0，因为一开始假设直线和某个像素点正好相交，我们从这个交点开始画线。
- 摆脱浮点运算
  - 现在要比较d和0.5的大小关系，不如把他转化为只需要判断符号，这样我们才方便乘数字来消除浮点数。
  - 于是定义 $e=d-0.5$，那么很自然地 $e_0=-0.5$，增量仍然是k。如果 e>0，那么选右上点，否则选右点；如果选了右上的点，$e=e-1$。
  - 观察可知，和未改进的Bresenham类似，其中涉及的浮点数包括初始值-0.5和k，因此仍然可以乘 $2\Delta x$。
  - 于是定义 $e=2\Delta x(d-0.5)$，那么很自然地 $e_0=-\Delta x$，增量是 $2\Delta y$ 。如果 e>0，那么选右上点，否则选右点；如果选了右上的点，$e=e-2\Delta x$。

#### 进行推广

- 我们只讨论了 $0\leq k\leq1$的情况。如果 k>1，那么把x、y关系反过来（也就是y是变化较快的那一个，故取y为迭代器）；如果k<0，那么让其中一个变化相反。

#### Bresenham八分画圆

- 因为圆具有良好的对称性，且任意位置的圆可以移动到(0,0)，绘制完成再移动回去。所以直接考虑八分一个原点处的圆即可。八分是因为圆可以被y=x，y=-x划分成8份，其他部分直接利用对称即可直接把点得到。无需计算。
- 思想和Bresenham画线完全一致：判断中点和待画的线的关系。也就是把中点代入隐式方程，判断符号即可。注意这里因为考虑从 $x=0$到 $y=x$这一段的圆弧，所以候选点是右边和右下。
- 改为递推（递增）
  - 和未改进Bresenham一样。设上一个画的点是 $(x_i,y_i)$。
    - 如果上次选了右，即本次是 $(x_i+1,y_i)$，那么下面俩候选点的中点是 $(x_i+2,y_i-0.5)$，代入隐式方程 $F(x,y)=x^2+y^2-R^2$，得到 $F(x_i+2,y_i-0.5)=(x_i+2)^2+(y_i-0.5)^2-R^R$，而旧的d是 $F(x_i+1,y_i)=(x_i+1)^2+y_i-R^R$，二者做差，得到 $\Delta d=2x_i+3$.
    - 同理，得到如果上次是右下点，则 $\Delta d=2(x_i-y_i)+5$.
  - 算初值： $F(1,R-0.5)=1.25-R$。
- 摆脱浮点运算
  - 观察初值和递推：其中如果R是整数，那么只有1.25是小数，而且之后的递推中也没有出现小数，那么只需要把1.25干掉就没有小数了。
  - 因此让d=d-0.25即可。这样就消除了小数了。
    - $d_0=1-R$，且判断d和0的关系改为判断d和0.25的关系。
  - 因为中间不可能产生任何小数了，所以“判断d和0.25的关系”也没有必要了，它不可能这么精确，因为只能是整数。**因此可以直接改成判断d的符号。**
    - 因为R的单位是像素，所以必然是整数。

## 多边形扫描转化

#### 扫描线填充

- 算法流程
  - 定界：确定ymax，ymin，从而确定最高和最低扫描线
  - 求交：对扫描线和多边形的边进行求交
  - 排序：对边表中的边进行排序
  - 填色：交点配对然后填色
- 优化要点
  - 求交：利用了y方向上的连贯性：只与有效边求交，且利用增量计算求交点，并简化顶点判断（让新边表中相关的边的 $y_{max}$ 减1）
  - 排序：只在新边加入时才有必要排序
- NET和AET
  - 新边表（NET）
    - 是一个链表，其中每个节点对应一个y值。如果某多边形的范围是y=2到y=10，那么它的节点依次与y=2、3、4、5、6、7、8、9、10相关，这里我们称为桶。每个桶也都是链表头，该链表挂了所有y值为它的边。
    - 确定边对应的y值：我们从y=2到y=10进行扫描，按这种扫描顺序，每条边第一次被扫描到的y值作为其y值，放到该y值对应的桶中。
      - 因为y值是第一次扫描到他而确定的，所以才称为“新边”。
    - 每个桶后面挂的链表的节点结构如下
      - x：第一次扫描到这条边时的x值（即这条边y值较小的端点的x值），用于排序。
      - $y_{max}$：这条边扫描结束时的y值（即这条边y值较大的端点的y值），用于结束扫描他。
      - $\frac{1}{k}$：增量。因为我们以y为迭代器（扫描线沿y方向移动），所以增量是 $\frac{1}{k}$而不是k。可以类比DDA。用于增量求交、排序。
      - ~~next：链表next域。~~
    - 每个桶后面挂的链表的排序规则
      - 是双关键字排序，首先按照x值升序，然后按照增量升序。
      - 这样就能保证在扫描线向上运动时，扫描线与这些边的交点的x值是升序的。于是才能从左扫描到右。
    - 扫描线刚好通过多边形边顶点的取舍问题
      - 则该顶点可以按0个、1个或2个来计。我们约定这个顶点代表的顶点个数=其连接的两条边位于扫描线上方的个数。如果两条边都在上方，那就是算作2个顶点，否则类似的有1个、0个。
      - 为了简化判断，让新边表中相关的边的 $y_{max}$ 减1。这样一来，就自动满足了上述的约定。可以举个例子试一试，简直精妙绝伦。
  - 活性边表（AET）
    - 活性边的定义
      - 当前与扫描线**正在相交**的那些边。
    - AET桶内链表节点的结构
      - 和NET的基本一样，只不过把x换成“与此y值的扫描线相交的x坐标”。
      - 可见，如果要把新边加入进来，只需要复制NET中的这个边的节点即可。因为“与此y值的扫描线相交的x坐标”就是“第一次扫描到这条边时的x值”。
    - AET的构造（利用增量进行计算）
      - 把y下的扫描线对应的活性边构成链表，存放在AET对应y值的桶中
      - 遍历每个处于ymin和ymax之间的扫描线，**按照之前约定的排序规则**，按照正确的顺序把该线对应的活性边都链接在里面。
      - 注意，虽然是遍历，但是下一个y值的桶要根据上一个y值的桶得到。所以实际上是一个迭代的过程。
        - 如果是ymin的桶，那么直接把NET中的ymin的桶复制过来。（因为相当于所有的边都是刚刚被扫描到）
        - 否则，复制上一个y值的桶，然后：
          - 如果没有边失效，或没有新边加入，那么就**然后利用 $\frac {1}{k}$ 对各边进行增量计算，算出新的x填入**，即可完成本y值桶的构造。
          - 如果有边失效，也就是当前的y值大于了节点中记录的该边的ymax，那么直接把他从该桶的链表中删除。
          - 如果新边生效，也就是当前的y值在NET的该y的桶的链表非空，那就在那个链表中直接把新边摘过来（或者说是复制过来），放到新AET中这个新构造的链表中**，然后重新为这些边排序**，也就是需要插入到这个新链表的**合适**位置。
      - 对每条扫描线都这么做，即可将AET构造完成。
      - AET中的每个桶，其带的链表都必然是偶数条边。（因为做了之前的ymax-1优化，解决了扫描线穿过顶点的问题），所以都能自然地完成配对。于是就可完成填色。

#### 区域填充

- 四连通和八连通
  - 考虑一个九宫格。中间的点的上、下、左、右称为四连通；如果把剩下那四个也算上就是八连通。
  - 注意，八连通填充算法不能填充四连通边界表示的区域，因为会跨越出去。但是如果采用内点表示，就没有问题。因为前者通过判断扫描到的点是否是边界颜色来判断是否把新点入栈，但是后者通过判断是否是内点颜色。如果某点在区域外，那么它必然不会被入栈。
- 边界填充算法和泛填充算法
  - 给定种子点、边界颜色，则将该种子点入栈。
  - 即利用bfs的思想。根据是四连通还是八连通来决定每次要发现当前点周围的哪些点。能入栈的条件是对其颜色的判断（对于边界填充是否非边界颜色且未被置为目标颜色，或对于泛填充是否非内点颜色且未被置为目标颜色。）。区别是这里采用栈而不是队列，且没有vis数组，存在重复入栈的可能性。
  - 边界填充算法通常用于给区域着色。泛填充算法通常用于给区域**重新**着色。因为前者适用于边界表示，后者适用于内点表示。
    - 4连通边界填充算法
    - 8连通边界填充算法
    - 4连通泛填充算法
    - 8连通泛填充算法
- 改进的填充算法
  - 为了防止重复入栈。于是引入扫描线思想。
  - 每次一个点出栈，就向左、向右都进行填充（沿着当前y的扫描线），直到遇到边界为止。
  - 然后在刚才填充的这一段扫描线区间检查上、下两条扫描线的该横坐标区间区域，如果可以入栈，就把这个区间的**x最大的（即最右边的）**像素作为种子入栈。
  - 为什么要分区间？因为如果是凹多边形，会存在这样的问题。同一个y扫描线，可能穿过两对可以配对的交点。这种情况也就是俩区间了。当然还有更复杂的情况，例如一个梳子。

#### 反走样

- 反走样带来的问题

  - 锯齿明显
  - 丢失细节（例如某较小的点（其宽度小于像素直径）位于两个像素之间），则它点不亮任何一个像素。
    - 如果这是一个动画，设想该点在进行平移，那么他会时隐时现。因为当它比较接近所在像素的中心的时候，才能点亮所在像素。

- 走样的本质

  - 用离散量表示连续量带来的失真，是光栅化的必然产物。

- 减轻走样

  - 提升分辨率

    - 并不能消除锯齿，而是只能让锯齿更加细腻。

  - 超采样（后滤波）

    - 用较高的分辨率，例如2倍于原来的分辨率，于是就能把原来的一个像素分成若干子像素，例如这里用2倍超采样，就能1分4。在这种虚拟的分辨率下进行计算（例如运行Bresenham），然后对原来每个像素的区域包含的4个子像素的亮度取平均值，得到该像素的亮度结果。
    - 例如上面采用了2倍超采样，那么每个像素的亮度级别就变成了5级。因为对4个子像素的亮度进行求均，可以得到0-4共5级，分别代表其中有几个子像素被点亮了。

  - **重叠超采样（常用）**

    - 例如屏幕分辨率是`m*n`，那么就可以提升虚拟分辨率到`(2m+1)*(2n+1)`，这样就能让原本每个像素的中心都对应一个子像素，而该子像素被周围八个其他子像素所包围，成为一个类似于卷积核的中心，且超采样前原本相邻的像素，在超采样后，他们所在的九宫格会共享边上的3个子像素。

    - 这样的好处是原本相邻的像素在超采样后会进行互相影响（因为共享了3个子像素），解决了普通的超采样中颜色跳变的问题。像素之间能够实现更均匀的过渡。

    - 既然得到了九宫格，我们还能像卷积那样，对它进行加权平均来计算最终亮度。例如下面就是三种加权方式：

    - $$
      \begin{bmatrix}
      1&2&1\\
      2&4&2\\
      1&2&1
      \end{bmatrix}
      \begin{bmatrix}
      1&1&1\\
      1&2&1\\
      1&1&1
      \end{bmatrix}
      \begin{bmatrix}
      0&1&0\\
      1&4&1\\
      0&1&0
      \end{bmatrix}
      $$

    - 通过加权，可以实现越靠近中心，对原本像素的影响越大。这样能进一步实现平滑！

  - 区域取样（前滤波）

    - 把直线看做一个条带，而并不是一条理想直线。于是该条带由于具有宽度，可以对像素进行一定面积的覆盖。则覆盖的面积越大，像素的颜色就越接近线的颜色，否则越接近底色。
    - 这个可以通过计算直线条覆盖该像素的面积来实现。
      - 给出一个像素，以及待计算直线条边界进入该像素区域的具体起始位置，以及该直线的k，即可算出。因为只有两种情况：可能是三角形覆盖区域，可能是梯形覆盖区域。
      - 或者可以继续采用超采样的思想：把像素进一步分割，然后计算子像素中心落入直线条内的子像素的个数，就能近似得出直线占该像素的面积了。
    - 效果不如超采样：因为它是基于覆盖面积来计算亮度，不能达到计算直线和像素中心的距离来得出亮度等级的目的。因为如果覆盖面积相同，不能保证该距离也相同。

## 几何造型技术

#### 参数连续性

- n阶参数连续性即在连接处的从0到n阶导数值相等。
- 例如 $C^2$连续性指的是在连接处相连，且1、2阶导数值相等。

#### 几何连续性

- n阶几何连续性保证在连接处的从0到n阶导数成比例，体现在几何上就是切向量的方向相等，而长度不要求相同。
- $G^0$等价于 $C^0$。

#### 贝塞尔曲线

- 特点

  - 曲线通过第一个控制点和最后一个控制点
  - 曲线第1个控制点处的切线与第1、2控制点连线共线；曲线最后一个控制点与倒数第1个、倒数第2个控制点连线共线
  - 在凸包内

- 伯恩斯坦基

  - $B_i^{(n)}(t)=C_n^it^i(1-t)^{n-i}$.

- 曲线上的点

  - $[x,y,z]=\sum\limits_{i=0}^nB_i^{(n)}\cdot[x_i,y_i,z_i]$.
  - 也就是各自乘伯恩斯坦基的一项，作为一种权重，进行混合。

- 伯恩斯坦基的性质

  - 权性

    - 因为伯恩斯坦基函数可以看做是$[t+(1-t)]^n$的展开式，所以在u取任何值的时候，各项相加必然是1.而且u的取值一定要是在 $[0,1]$才符合这个要求。
      - 这样一来，就能当成权重去使用了，也就是给每个控制点分配一个这样的“项”。于是，把他们分别当做权重，**利用这种权重对各控制点进行加权平均，**就能画出贝塞尔曲线上的点。
      - 坏处就是有多少点，就有多少点参与其中进行加权，会牵一发动全身。
      - 可以使两个点重合实现加权。

  - 凸包性

    - 因为是加权混合而来，所以必然在凸包内。

  - 升阶

    - $B^n_i(t)=(1-t)B^{(n-1)}_i(t)+tB^{(n-1)}_{i-1}(1-t)$.

    - 利用两个基函数的项可生成一个比他高一阶的基函数的项。

    - 原理：$C_n^i=C_{n-1}^i+C_{n-1}^{i-1}$.

    - 对贝塞尔曲线进行升阶

      - **可以做到曲线形状完全不变，但是多出来一个控制点。**

    - 应用：De Casteljau算法

      - 考虑从0阶开始升阶。每次都利用伯恩斯坦基的升阶公式得到一个更高阶的基。

      - 从而贝塞尔曲线具有了 $b^{(r)}_i=(1-t)b^{(r-1)}_i+tb^{(r-1)}_{i+1}$的性质。**注意这里的b是贝塞尔曲线上的点，而不是基函数。**也就是说，用两个低一阶的贝塞尔曲线上的点可以线性组合出高一阶的贝塞尔曲线上的点。

      - 所以，可以像动态规划一样，从0阶开始，依次计算出0阶上的几个点，然后让他们组合依次计算出1阶上的，以此类推。其中，0阶的点实际上就是给定的几个控制点。

      - ```c++
        for r=1..n
            for i=0..n-r
                b[r][i]=(1-t)b[r-1][i]+tb[r-1][i+1]
        return b[n][0];
        ```

- 贝塞尔曲线的拼接条件

  - C1：保证三点共线，且拼接点是其他两个控制点的中点。
  - G1：和C1一样，但是不用保证中点。

#### B样条曲线

- 基函数
  - $N^1_i(t)=\cases{1,(t\in [i,i+1])\\0,otherwise}$.可见，它的作用范围是i到i+1这段区间。它属于一个1阶（也就是0次）基函数。后续的高阶基函数都要以它为依据升阶得到。显然他是具有权性的：在它管辖的区间内，是1.
  - 之后，取 $N^k_i(t)=\frac{t-i}{(i+k-1)-i}N^{k-1}_i(t)+\frac{(i+k)-t}{(i+k)-(i+1)}N^{k-1}_{i+1}(t)$.于是可以通过这种方式进行两两组合，从而升阶。
    - de boor算法就是利用的这个公式。
    - 每升一阶，管辖的区间长度+1.以1阶升2阶（即0次升1次）来说，显然要合并[i,i+1]和[i+1,i+2]，合并完了就是[i,i+2]，长度+1.然后继续升，则是[i,i+2]和[i+1,i+3]合并，完了是[i,i+3]。
- 节点向量
  - 对于均匀B样条，实际上节点向量没那么重要，因为它无非就是 $[0,1,2,3,...]$，但是对于非均匀B样条，它记录了每个节点所取的参数！因为对于k阶曲线来说，它的基函数管辖长度为k的区间，设有从 $d_0$到 $d_n$共n+1个控制顶点， 则k阶B样条的节点向量有n+k+1个元素，即 $[t_0,t_1,...,t_{n+k}]$.
- 性质
  - 基函数只在其管辖区间内非0，都是从其管辖区间开始时的参数 $t_i$到 $t_{i+k}$结束。（也就解释了节点向量下标最大值为什么是n+k，因为最后一个的区间是这样的。）
  - 如果一段曲线受到k个点的控制，那就是k阶B样条，也就是k-1次B样条，也就是控制它的样条基有k个（因为每个点都乘这个基来进行加权）。
  - 不同段的B样条之间的连接处的连续性是 $C^{k-2}$的。例如使用3次B样条（即4阶B样条），它的k=4，那么能够做到拼接处自动拥有了 $C^2$的连续性。因此，我们使用3次B样条会比较多一些。因为连续性能达到要求，而且计算代价又没那么大。
  - 如果某点处出现控制点重合，设其重数是m，那么此连接处的连续性是 $C^{k-m-1}$，也就是每重合一次，连续性就在原来的基础上再减去1.于是可以利用这种性质来构造尖点，或控制光滑性。
  - 对于k阶B样条，如果首、末控制点的重数都是k重，**那么B样条曲线退化为k阶贝塞尔曲线。**（注意，都得是k重才可以。）（样条基退化成了贝塞尔基。）
- de boor算法
  - 通过降阶，把 $N^k_i(t)=\frac{t-i}{(i+k-1)-i}N^{k-1}_i(t)+\frac{(i+k)-t}{(i+k)-(i+1)}N^{k-1}_{i+1}(t)$.化成与点有关的式子。
  - **它的割角法和贝塞尔的很类似，只不过是在被管线区间内的那些点进行而已。**

## 裁剪

#### Cohen-Sutherland算法

- 裁剪的思想：简取、简弃、分治
  - 简取：如果线段的两个端点都在屏幕空间，就可以完全保留这条线，并结束算法；
  - 简弃：如果两个端点同时在屏幕左、同时在屏幕右、同时在屏幕上、同时在屏幕下，就可以丢弃这条线，并结束算法；
    - 注意，一定得是**“同时都在”**，否则不能保证其是否有中间的部分穿过屏幕空间，这样也就不能“**简**弃”了。
  - 分治
    - 如果不能简取也不能简弃，则需要与屏幕**求交**，**按得到的交点分段**，然后对这些线段重新跑Cohen-Sutherland。
    - 因为对这些线段又跑这个算法，所以这是分而治之。
- 核心思想：编码
  - 把屏幕和其八连通区域当成9宫格。每个宫格都对应着自己的编码。其中，屏幕空间的编码是`0000`。
  - 四位二进制：`上下右左`。例如一个端点在屏幕之外的右上区域，那就是`1010`.
  - 现在对线段的端点进行这样的编码处理。
    - 如果`C1|C2==0`，那么一定全是0，那么简取。
    - 如果`C1&C2!=0`，那么一定存在至少一位都是1，那么简弃。
    - 否则，分而治之：按`左下右上`的顺序与屏幕边界求交。分成若干条线段，重复上述过程。
- 优点
  - 对窗口很大或窗口很小的情况有很高的效率。因为可以直接保留或放弃。
- 缺点
  - 如果不能简取、简弃，就只能求交，略慢。

#### 改进Cohen-Sutherland算法

- 对算法的缺点给出改进：不再求交，而是使用二分逼近交点。

#### Liang-Barsky算法

- 核心思想
  - 将直线的连续性应用进来：即它不可能从中间断掉，所以可以利用其连续性。
  - 把直线穿过屏幕空间分成四个过程：靠近、进入、离开、远离。
    - 例如从上界靠近，从左界进入，从右界俩开，从下界远离。可以想象，这是一个斜率绝对值很小的直线。
    - 注意，这里的屏幕“界”是直线，而不是线段。因此才能做到“靠近”、“远离”的过程。
    - 注意，这里的“线”也不是待裁剪的线段，而是这个线段**所在的直线**。因此才能做到“靠近”、“远离”的过程。然而，实际的待裁剪的线段并**不一定能走完**“靠近、进入、离开、远离”四个过程，它可能从任意一个环节才开始，或者从某一个环节就提前离开。
    - 因此，最终的输出要么是线段的端点，要么是它的“靠近/进入/离开/远离”点。虽然后者一定是从"进入/离开"两种点中取，**但是为了判断方便**，我们从这四个里面找即可。