 

## 画线画圆

#### DDA

- 因为在迭代算法中，每一轮循环的结果都是在上一轮循环的基础上加一个增量得到的，所以称为增量算法。
- 约定屏幕空间是一个二维坐标系的第一象限。
- 如果待扫描转换的线的k>1，那么y增长的比较快，否则x增长的比较快。我们选择增长比较快的那个量，让他每次有1的增量，然后另一个增长比较慢的量的增量根据块的那个量的增量算出。例如x增长快，那么 $x_i=1,y_i=k$；如果y增长快，那么 $y_i=1,x_i=\frac{1}{k}$。
  - 为什么让增长快的那个的增量=1？因为这样就能保证在增长快的那个方向上，拥有连续变化的像素。（因为增长1只会跨越1个像素）。因为像素的长度是1.
  - 而且，如果让增长慢的那个是1，那么快的那个的增量就会>1，就会导致在它的方向上，像素不再连续，造成直线**断断续续**的情况。
- 缺点：存在浮点运算，慢。（舍入取整）
  - 如何对一个浮点数进行取整？ `(int)(x+0.5)`即可。

#### Bresenham

- 以 $0\leq k\leq 1$为例，此时根据DDA的思想，x是每次增量较大的那一个，所以取x为迭代器，每次+1.
- 设当前绘制了点 $(x_i,y_i)$ ，在+1的过程中，判断直线上的点 $F(x)$ 和两个候选点的中点 $(x_i+1,y_i+0.5)$的上下关系，如果 $F(x)$在中点的上方，则取点 $(x_i+1,y_i+1)（右上点）$，否则取 $(x_i+1,y_i)$（右边点）。
- 由直线方程，得到隐式方程 $y-kx-b=0$，而把点 $(x_i+1,y_i+0.5)$代入，如果隐式方程>0，则说明中点位于线下方；否则位于线上方，即可完成判断。
  - 即：观察判别式 $y_i+0.5-k(x_i+1)-b$的符号。
  - 设 $d=y_i+0.5-k(x_i+1)-b$.
- 改为递推（递增）
  - 需要根据上次画点的情况得到本次画点所需的误差项。
  - 如果上次画点 $(x_i,y_i)$，
    - 那么如果上次取下一个点为“右上”，那么本次的点的坐标实际上是 $(x_i+1,y_i+1)$，本次的中点就变成了 $(x_i+2,y_i+1.5)$，把 $(x_i+2,y_i+1.5)$代入隐式方程，整理得 $F(x_i+2,y_i+1.5)=d-k+1$，也就是本次画点需要得出新点的误差是d-k+1.
    - 如果上次取下一个点为“右”，那么本次的点的坐标实际上是  $(x_i+1,y_i)$，那么新点要参照的中点是 $(x_i+2,y_i+0.5)$，代入隐式方程，整理得 $F(x_i+2,y_i+0.5)=d-k$，也就是本次画点需要得出新点的误差是d-k.
  - 总结：如果上次画点右上，那么本次需要的误差是d-k**+1**否则是d-k（不用+1）。
  - d的初值是什么？将 $(x_0+1,y_0+0.5)$代入隐式方程，得 $F(x_0+1,y_0+0.5)=0.5-k$.也就是d应该取初值0.5-k。
- 摆脱浮点运算
  - 因为新d是老d-k+1，或老d-k，且d的初值是0.5-k，所以只需要把0.5和k这两个浮点数变成整数。因为我们只需要判断d的符号，所以任意乘一个倍数并不影响判断。因此乘2（消除0.5）再乘 $\Delta x$（消除k）。
  - 于是，把上述的算法中的d都乘 $2\Delta x$即可，其他不变（x还是每次都+1，y还是+0或+1，但是d的迭代变成了 $2d\Delta x-2\Delta y+ 2\Delta x$ 或 $2d\Delta x-2\Delta y$（也就是d的增量变成了原来的 $2\Delta x$倍。））

#### 改进Bresenham算法

- 仍然以 $0\leq k\leq 1$为例，此时根据DDA的思想，x是每次增量较大的那一个，所以取x为迭代器，每次+1.
- 设刚才画了点 $(x_i,y_i)$，根据Bresenham思想，现在的任务是确定x取 $(x_i+1)$时y的取值是否+1。引入简洁误差d，表示待画的线在 $x=x_i+1$处的y值和 $y_i$的差值，设为d。如果 $d>0.5$，则下一个y取 $y_i+1$，否则取 $y_i$。注意，如果取了 $y_i+1$，**那么需要让d再减去1。**
- 改为递推（递增）
  - 显然，每次迭代，d会增加k。因为交点一直都在待画的直线上。因此我们获得了其增量=k。
  - 初始值=0，因为一开始假设直线和某个像素点正好相交，我们从这个交点开始画线。
- 摆脱浮点运算
  - 现在要比较d和0.5的大小关系，不如把他转化为只需要判断符号，这样我们才方便乘数字来消除浮点数。
  - 于是定义 $e=d-0.5$，那么很自然地 $e_0=-0.5$，增量仍然是k。如果 e>0，那么选右上点，否则选右点；如果选了右上的点，$e=e-1$。
  - 观察可知，和未改进的Bresenham类似，其中涉及的浮点数包括初始值-0.5和k，因此仍然可以乘 $2\Delta x$。
  - 于是定义 $e=2\Delta x(d-0.5)$，那么很自然地 $e_0=-\Delta x$，增量是 $2\Delta y$ 。如果 e>0，那么选右上点，否则选右点；如果选了右上的点，$e=e-2\Delta x$。

#### 进行推广

- 我们只讨论了 $0\leq k\leq1$的情况。如果 k>1，那么把x、y关系反过来（也就是y是变化较快的那一个，故取y为迭代器）；如果k<0，那么让其中一个变化相反。

#### Bresenham八分画圆

- 因为圆具有良好的对称性，且任意位置的圆可以移动到(0,0)，绘制完成再移动回去。所以直接考虑八分一个原点处的圆即可。八分是因为圆可以被y=x，y=-x划分成8份，其他部分直接利用对称即可直接把点得到。无需计算。
- 思想和Bresenham画线完全一致：判断中点和待画的线的关系。也就是把中点代入隐式方程，判断符号即可。注意这里因为考虑从 $x=0$到 $y=x$这一段的圆弧，所以候选点是右边和右下。
- 改为递推（递增）
  - 和未改进Bresenham一样。设上一个画的点是 $(x_i,y_i)$。
    - 如果上次选了右，即本次是 $(x_i+1,y_i)$，那么下面俩候选点的中点是 $(x_i+2,y_i-0.5)$，代入隐式方程 $F(x,y)=x^2+y^2-R^2$，得到 $F(x_i+2,y_i-0.5)=(x_i+2)^2+(y_i-0.5)^2-R^R$，而旧的d是 $F(x_i+1,y_i)=(x_i+1)^2+y_i-R^R$，二者做差，得到 $\Delta d=2x_i+3$.
    - 同理，得到如果上次是右下点，则 $\Delta d=2(x_i-y_i)+5$.
  - 算初值： $F(1,R-0.5)=1.25-R$。
- 摆脱浮点运算
  - 观察初值和递推：其中如果R是整数，那么只有1.25是小数，而且之后的递推中也没有出现小数，那么只需要把1.25干掉就没有小数了。
  - 因此让d=d-0.25即可。这样就消除了小数了。
    - $d_0=1-R$，且判断d和0的关系改为判断d和0.25的关系。
  - 因为中间不可能产生任何小数了，所以“判断d和0.25的关系”也没有必要了，它不可能这么精确，因为只能是整数。**因此可以直接改成判断d的符号。**
    - 因为R的单位是像素，所以必然是整数。

## 多边形扫描转化

#### 扫描线填充

- 算法流程
  - 定界：确定ymax，ymin，从而确定最高和最低扫描线
  - 求交：对扫描线和多边形的边进行求交
  - 排序：对边表中的边进行排序
  - 填色：交点配对然后填色
- 优化要点
  - 求交：利用了y方向上的连贯性：只与有效边求交，且利用增量计算求交点，并简化顶点判断（让新边表中相关的边的 $y_{max}$ 减1）
  - 排序：只在新边加入时才有必要排序
- NET和AET
  - 新边表（NET）
    - 是一个链表，其中每个节点对应一个y值。如果某多边形的范围是y=2到y=10，那么它的节点依次与y=2、3、4、5、6、7、8、9、10相关，这里我们称为桶。每个桶也都是链表头，该链表挂了所有y值为它的边。
    - 确定边对应的y值：我们从y=2到y=10进行扫描，按这种扫描顺序，每条边第一次被扫描到的y值作为其y值，放到该y值对应的桶中。
      - 因为y值是第一次扫描到他而确定的，所以才称为“新边”。
    - 每个桶后面挂的链表的节点结构如下
      - x：第一次扫描到这条边时的x值（即这条边y值较小的端点的x值），用于排序。
      - $y_{max}$：这条边扫描结束时的y值（即这条边y值较大的端点的y值），用于结束扫描他。
      - $\frac{1}{k}$：增量。因为我们以y为迭代器（扫描线沿y方向移动），所以增量是 $\frac{1}{k}$而不是k。可以类比DDA。用于增量求交、排序。
      - ~~next：链表next域。~~
    - 每个桶后面挂的链表的排序规则
      - 是双关键字排序，首先按照x值升序，然后按照增量升序。
      - 这样就能保证在扫描线向上运动时，扫描线与这些边的交点的x值是升序的。于是才能从左扫描到右。
    - 扫描线刚好通过多边形边顶点的取舍问题
      - 则该顶点可以按0个、1个或2个来计。我们约定这个顶点代表的顶点个数=其连接的两条边位于扫描线上方的个数。如果两条边都在上方，那就是算作2个顶点，否则类似的有1个、0个。
      - 为了简化判断，让新边表中相关的边的 $y_{max}$ 减1。这样一来，就自动满足了上述的约定。可以举个例子试一试，简直精妙绝伦。
  - 活性边表（AET）
    - 活性边的定义
      - 当前与扫描线**正在相交**的那些边。
    - AET桶内链表节点的结构
      - 和NET的基本一样，只不过把x换成“与此y值的扫描线相交的x坐标”。
      - 可见，如果要把新边加入进来，只需要复制NET中的这个边的节点即可。因为“与此y值的扫描线相交的x坐标”就是“第一次扫描到这条边时的x值”。
    - AET的构造（利用增量进行计算）
      - 把y下的扫描线对应的活性边构成链表，存放在AET对应y值的桶中
      - 遍历每个处于ymin和ymax之间的扫描线，**按照之前约定的排序规则**，按照正确的顺序把该线对应的活性边都链接在里面。
      - 注意，虽然是遍历，但是下一个y值的桶要根据上一个y值的桶得到。所以实际上是一个迭代的过程。
        - 如果是ymin的桶，那么直接把NET中的ymin的桶复制过来。（因为相当于所有的边都是刚刚被扫描到）
        - 否则，复制上一个y值的桶，然后：
          - 如果没有边失效，或没有新边加入，那么就**然后利用 $\frac {1}{k}$ 对各边进行增量计算，算出新的x填入**，即可完成本y值桶的构造。
          - 如果有边失效，也就是当前的y值大于了节点中记录的该边的ymax，那么直接把他从该桶的链表中删除。
          - 如果新边生效，也就是当前的y值在NET的该y的桶的链表非空，那就在那个链表中直接把新边摘过来（或者说是复制过来），放到新AET中这个新构造的链表中**，然后重新为这些边排序**，也就是需要插入到这个新链表的**合适**位置。
      - 对每条扫描线都这么做，即可将AET构造完成。
      - AET中的每个桶，其带的链表都必然是偶数条边。（因为做了之前的ymax-1优化，解决了扫描线穿过顶点的问题），所以都能自然地完成配对。于是就可完成填色。

