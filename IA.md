 

## 快速幂

------

#### 算法

```c++
long long qpow(long long a,long long b){
    if(b==0)return 1;
    long long ret=qpow(a,b/2);
    if(b%2)
        return ret*ret*a;
    else
        return ret*ret;
}
```

- 设计递归算法时，考虑最外层递归：只需要把两个次幂是`b/2`的乘起来即可得出最终结果。

## 时间复杂度

------

#### 三种记号

- $O((g(n))$
  - 当n很大时（较小时我们不关心），其时间复杂度 $t(n)$ 总以$g(n)$函数和一个常数的乘积 $c\cdot g(n)$为上界，即总有 $t(n)\leq c\cdot g(n)$成立。
- $\Omega((g(n))$
  - 当n很大时（较小时我们不关心），其时间复杂度 $t(n)$ 总以$g(n)$函数和一个常数的乘积 $c\cdot g(n)$为下界，即总有 $t(n) \geq c\cdot g(n)$成立。
- $\Theta((g(n))$
  - 当n很大时（较小时我们不关心），其时间复杂度 $t(n)$ 总被 $g(n)$函数和一个常数的乘积 $c_1\cdot g(n)$和**该**函数和另一个常数的乘积 $c_2\cdot g(n)$所**包夹**，即总有 $c_1\cdot g(n)\leq t(n)\leq c_2\cdot g(n)$成立。

## 图基础

------

#### 简单图

没有自环，没有多重边的图。

#### 孤立点

度为0的点。

#### 握手定理

- 无向图中，所有的度加起来是边数的二倍。因为一条边产生2度。
  - 推论：则度之和是偶数。那么为了保证度之和是偶数，奇数度的定点必须有偶数个，否则度之和就不可能是偶数。
- 有向图中，入度之和=出度之和。因为一条边产生1出度1入度。

#### 路径，通路，圈，回路

- 一些顶点组成的序列 $p=<v_0,v_1,...,v_k>$，如果每个 $v_i$都是不同的顶点，那么他是一条路径，否则是一条通路。
- 如果上述的路径满足 $v_0=v_k$，那么它是一个圈。如果上述的通路满足 $v_0=v_k$，那么它是一个回路。（可以看见，路永远对应路（不管是通路还是回路，它对应过来都带“路”）。）

#### 连通图

- 对于无向图：每个顶点之间都有路。
- 对于有向图：每个顶点之间都有路，那么是**强连通**的。

#### 特殊的图

- 完全图
  - 是一个无向图。该无向图每个顶点之间**都邻接**。
- 二分图
  - 对于 $G=(V,E)$，其 $V$可被分成两个集合 $V_1,V_2$。
  - 于是，对于任意 $(u,v)\in E$，有要么他是第一个集合里的点指向第二个集合里的点，要么是第二个集合里的点指向第一个集合里的点。
- 树
  - 是连通图，无环图。
  - 满足 $|E|=|V|-1.$
  - 满足任意两个顶点之间**都有唯一的路**。

#### 无向图邻接矩阵次方定理

- 对于一个图，其邻接矩阵是 $A$，那么 $A^k[i,j]$的意思是：从i到j有 $A^k[i,j]$条不同的长度为k的路。
- 证明：采用归纳法
  - 对于 $A^2[i,j]$，他是矩阵元素 $\Sigma A[i,m]\cdot A[m,j]$得来。其中，每个连加元素都是得当且仅当i到m邻接且m到j邻接才为1.也就是说，这样做就保证了路 $i \rightarrow m \rightarrow j$存在。可见其长度正好为2.因为连加，所以这样能统计出 $m\in V$的所有的这样的路。
  - 对于已经有这样的 $A^k[i,j]$，它本身代表了i到j有长度为k的通路的数量。对于这样的 $A^{k+1}[i,j]$，其等于 $\Sigma A^{k+1}[i,m]\cdot A[m,j]$，也就是从i到m经过了长度为k的路，然后再经过一条边到达j，构成了一条长度为k+1的i到j的通路。同样通过连加统计了这样的路的数量。
  - 得证。

## BFS

------

#### 算法简述

- 输入
  - 无向图或有向图$G$
  - 源点$s$
- 输出
  - 数组 $\pi[u]$，记录u的前驱
  - 数组 $d[u]$，记录s到u最短路径长度

#### 颜色

- 一开始，每个点都是白色。
- 当一个点入队，它变成灰色。（也就是某正在处理中的点扫描了它的邻居，则这些邻居变灰入队）
- 当一个灰色点被处理完毕，它变成黑色。

#### 前驱子图构成最短路径树

- 因为可以记录每个点（例如点i）的前驱，保存在数组 $\pi[i]$中。
- 于是，如果规定点集合V是所有的满足 $\pi[i]\neq NIL$的点构成的集合，然后把源点s加进来（因为源点不存在前驱，这样才完整），并且规定边集合E是所有的形如 $(\pi[i],i)$的边，于是得到了一个**前驱子图**。
- 因为这个前驱子图是满足 $|E|=|V|-1$的，所以我们得到了**最短路径树**。

#### BFS相关重要引理

- **a.**`三角不等式` 对于图中的任意边 $(u,v)$，必然有 $\delta(s,v)\leq\delta(s,u)+1$成立。
  - 如果s到u可达
    - 如果s到v必然可达。因为邻接，所以不等式成立。
  - 如果s到u不可达
    - 那么不等式成立。因为 $\delta(s,u)=\inf$，那么无论s到v是否可达，都是成立的。
- **b.**假设在图G上跑BFS，那么最终得到的数组d一定有 $d[v]\geq \delta(s,v)$成立。
- **c.**`BFS队列性质` 假设在图G上跑BFS，那么任意时刻其队列中的元素一定满足下面两个性质：
  - $d[v_r]\leq d[v_1]+1$ ，即队尾最多比队首多**一条边**的距离，也可能不多。
  - $d[v_i]<=d[v_{i+1}]$，即队列是单调递增的。（先入队的距离小，但是也最多差出去一条边）
  - $v_i$一旦入队， $d[v_i]$ 就不会发生变化了。（因为 $d[v_i]$是在发现时记录的）

#### BFS算法求最短路正确性证明

- 首先证明 $\delta(s,v)=d[v]$
  - 因为根据引理b，所有的点都满足$d[i]\geq\delta(s,i)$成立。如果要证明上式成立，只需要证明不存在严格大于的情况成立即可。
  - 因此反证：假设存在这样的点 $d[v]>\delta(s,v)$，且v是这种点里面d最小的那个。
    - 因为 $d[v]>\delta(s,v)$，则s到v必然可达，也就是存在s到v

