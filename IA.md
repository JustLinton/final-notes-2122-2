 

## 快速幂

------

#### 算法

```c++
long long qpow(long long a,long long b){
    if(b==0)return 1;
    long long ret=qpow(a,b/2);
    if(b%2)
        return ret*ret*a;
    else
        return ret*ret;
}
```

- 设计递归算法时，考虑最外层递归：只需要把两个次幂是`b/2`的乘起来即可得出最终结果。

## 时间复杂度

------

#### 三种记号

- $O((g(n))$
  - 当n很大时（较小时我们不关心），其时间复杂度 $t(n)$ 总以$g(n)$函数和一个常数的乘积 $c\cdot g(n)$为上界，即总有 $t(n)\leq c\cdot g(n)$成立。
- $\Omega((g(n))$
  - 当n很大时（较小时我们不关心），其时间复杂度 $t(n)$ 总以$g(n)$函数和一个常数的乘积 $c\cdot g(n)$为下界，即总有 $t(n) \geq c\cdot g(n)$成立。
- $\Theta((g(n))$
  - 当n很大时（较小时我们不关心），其时间复杂度 $t(n)$ 总被 $g(n)$函数和一个常数的乘积 $c_1\cdot g(n)$和**该**函数和另一个常数的乘积 $c_2\cdot g(n)$所**包夹**，即总有 $c_1\cdot g(n)\leq t(n)\leq c_2\cdot g(n)$成立。

## 图基础

------

#### 简单图

没有自环，没有多重边的图。

#### 孤立点

度为0的点。

#### 握手定理

- 无向图中，所有的度加起来是边数的二倍。因为一条边产生2度。
  - 推论：则度之和是偶数。那么为了保证度之和是偶数，奇数度的定点必须有偶数个，否则度之和就不可能是偶数。
- 有向图中，入度之和=出度之和。因为一条边产生1出度1入度。

#### 路径，通路，圈，回路

- 一些顶点组成的序列 $p=<v_0,v_1,...,v_k>$，如果每个 $v_i$都是不同的顶点，那么他是一条路径，否则是一条通路。
- 如果上述的路径满足 $v_0=v_k$，那么它是一个圈。如果上述的通路满足 $v_0=v_k$，那么它是一个回路。（可以看见，路永远对应路（不管是通路还是回路，它对应过来都带“路”）。）

#### 连通图

- 对于无向图：每个顶点之间都有路。
- 对于有向图：每个顶点之间都有路，那么是**强连通**的。

#### 特殊的图

- 完全图
  - 是一个无向图。该无向图每个顶点之间**都邻接**。
- 二分图
  - 对于 $G=(V,E)$，其 $V$可被分成两个集合 $V_1,V_2$。
  - 于是，对于任意 $(u,v)\in E$，有要么他是第一个集合里的点指向第二个集合里的点，要么是第二个集合里的点指向第一个集合里的点。
- 树
  - 是连通图，无环图。
  - 满足 $|E|=|V|-1.$
  - 满足任意两个顶点之间**都有唯一的路**。

#### 无向图邻接矩阵次方定理

- 对于一个图，其邻接矩阵是 $A$，那么 $A^k[i,j]$的意思是：从i到j有 $A^k[i,j]$条不同的长度为k的路。
- 证明：采用归纳法
  - 对于 $A^2[i,j]$，他是矩阵元素 $\Sigma A[i,m]\cdot A[m,j]$得来。其中，每个连加元素都是得当且仅当i到m邻接且m到j邻接才为1.也就是说，这样做就保证了路 $i \rightarrow m \rightarrow j$存在。可见其长度正好为2.因为连加，所以这样能统计出 $m\in V$的所有的这样的路。
  - 对于已经有这样的 $A^k[i,j]$，它本身代表了i到j有长度为k的通路的数量。对于这样的 $A^{k+1}[i,j]$，其等于 $\Sigma A^{k+1}[i,m]\cdot A[m,j]$，也就是从i到m经过了长度为k的路，然后再经过一条边到达j，构成了一条长度为k+1的i到j的通路。同样通过连加统计了这样的路的数量。
  - 得证。

## BFS

------

#### 算法简述

- 输入
  - 无向图或有向图$G$
  - 源点$s$
- 输出
  - 数组 $\pi[u]$，记录u的前驱
  - 数组 $d[u]$，记录s到u最短路径长度
- 复杂度
  - $O(V,E).$
  - 分析：初始化时，给每个点涂色为白色，需要V的；每次处理一个点，都会扫描其邻接点，所以相当于把所有的边扫描了一遍，需要E的；所以是V+E的。

#### 颜色

- 一开始，每个点都是白色。
- 当一个点入队，它变成灰色。（也就是某正在处理中的点扫描了它的邻居，则这些邻居变灰入队）
- 当一个灰色点被处理完毕，它变成黑色。

#### 前驱子图构成最短路径树

- 因为可以记录每个点（例如点i）的前驱，保存在数组 $\pi[i]$中。
- 于是，如果规定点集合V是所有的满足 $\pi[i]\neq NIL$的点构成的集合，然后把源点s加进来（因为源点不存在前驱，这样才完整），并且规定边集合E是所有的形如 $(\pi[i],i)$的边，于是得到了一个**前驱子图**。
- 因为这个前驱子图是满足 $|E|=|V|-1$的，所以我们得到了**最短路径树**。

#### BFS相关重要引理

- **a.**`三角不等式` 对于图中的任意边 $(u,v)$，必然有 $\delta(s,v)\leq\delta(s,u)+1$成立。
  - 如果s到u可达
    - 如果s到v必然可达。因为邻接，所以不等式成立。
  - 如果s到u不可达
    - 那么不等式成立。因为 $\delta(s,u)=\inf$，那么无论s到v是否可达，都是成立的。
- **b.**假设在图G上跑BFS，那么最终得到的数组d一定有 $d[v]\geq \delta(s,v)$成立。
- **c.**`BFS队列性质` 假设在图G上跑BFS，那么任意时刻其队列中的元素一定满足下面两个性质：
  - $d[v_r]\leq d[v_1]+1$ ，即队尾最多比队首多**一条边**的距离，也可能不多。（注意，**下标小的是队尾**）
  - $d[v_i]<=d[v_{i+1}]$，即队列是单调递增的。（先入队的距离小，但是也最多差出去一条边）
  - $v_i$一旦入队， $d[v_i]$ 就不会发生变化了。（因为 $d[v_i]$是在发现时记录的）
- **d.**`最短路子路必然是最短路` 一个最短路的子路必然都是最短路，否则就可以替换，得到更短的这样的最短路。

#### BFS算法求最短路正确性证明（证明d=delta，确实最短）

- 首先证明 $\delta(s,v)=d[v]$
  - 因为根据引理b，所有的点都满足$d[i]\geq\delta(s,i)$成立。如果要证明上式成立，只需要证明不存在严格大于的情况。
  - 因此反证：假设存在这样的点 $d[v]>\delta(s,v)$，且v是这种点里面 $\delta(s,v)$ 最小的那个。
    - 因为 $d[v]>\delta(s,v)$，则s到v必然可达，也就是存在s到v的最短路。假设这条最短路是s~>u->v，在最短路上，v的前驱是u。（但是不一定满足 $\pi[v]=u.$因为这里的$\pi[v]$是BFS的变量，现在认为他和最短路没关系，因为还没有得到证明。）
    - 因为u在s到v的最短路上，根据**引理d**，有 $d[u]=\delta(s,u).$（因为子路也是最短的）
    - 由假设，可知 $d[v]>\delta(s,v)=\delta(s,u)+1=d[u]+1$，（因为是前驱）。即需要存在一种情况，使得满足条件 $d[v]>d[u]+1$，假设才成立。
    - **考虑u出队时：**
      - 如果v为白色（即未入队），那么根据**算法**（u出队时扫描其邻接的白色定点，让他们的d为其的+1），有 $d[v]= d[u]+1$.不满足上述条件；
      - 如果v为黑色，那么根据**引理c**，有 $d[v]\leq d[u]$.
      - 如果v为灰色，那么根据**引理c**，有有 $d[v]\leq d[u]+1$.
    - 所以，无论如何都不能让 $d[v]>d[u]+1$（也就是v比u更早）成立。假设不成立，原命题得证。

#### BFS算法求最短路正确性证明（证明pi在最短路上）

- 然后证明：如果在BFS算法中，如果有 $\pi[v]=u$（这是这个定理的关键），那么沿着s到u的最短路走到u，然后再走到v（即d再+1），那么这两段加起来是s到v的最短路。
  - 因为 $\delta(s,v)=d[v]=d[\pi[v]]+1=\delta(s,\pi[v])+1$
    - 其中， $\delta(s,v)=d[v]$是因为上述定理
    - $d[v]=d[\pi[v]]+1$是因为 $\pi[v]=u.$
  - 所以 $\delta(s,v)=\delta(s,\pi[v])+1$ 得证。即沿着s到u的最短路走到u，然后再走到v（即d再+1），那么这两段加起来是s到v的最短路。
- 因此，BFS用这种方法求到的是最短路。因为 $\delta(s,v)=d[v]$是成立的。

#### 证明BFS生成的前驱图是一棵最短路径树

- 最短路径树的定义
  - 1）包含所有的从s可达的顶点
  - 2）对于一个可达点，从s到他的路径在这个前驱图中唯一。且最短。
- 证明这个前驱图是最短路径树
  - 根据BFS算法定义，1）成立；
  - 因为满足 $|E|=|V|-1$，所以它是树，所以这种路径是唯一的；又因为对于任意的v，一定有 $\delta(s,\pi[v])+1=\delta(s,v)$，也就是BFS生成的 $\pi[v]$ 一定在s到v的最短路上，所以可以这样递归地证明每个点到s都是最短的。所以2）成立。

