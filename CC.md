#### 3-存储程序

- 程序一旦运行，不需要人工干预即可自动执行

#### 3-冯诺依曼机器特点

- 采用存储程序的方式
- 计算机由5大部分构成
- 数据和指令在存储器中，以二进制表示，且没有区别，但计算机能区分
  - 指令由操作码和地址码构成
- 控制器能自动执行指令，运算器能进行算术和逻辑运算
- 操作人员使用IO操作计算机

#### 4-通用寄存器组（GPRs）

- General Propose Registers.用于临时存放CPU从主存取来的数据或运算中间结果

#### 6-时钟周期

- 时钟信号的宽度称为时钟周期

#### 7-程序语言和自然语言的区别

- 程序语言不存在二义性，且具有严格的执行顺序

#### 7-机器语言

- 即0-1序列
- 汇编语言必须转换成机器语言才能执行

#### 8-翻译程序

- 翻译程序分为汇编程序assembler、解释程序interpreter、编译程序compiler三个大类。
- 汇编程序把汇编语言转换为机器语言
- 解释程序把源程序**按执行顺序**翻译成机器指令并**立即执行**
- 编译程序把**高级语言**源程序翻译成汇编或机器语言

#### 8-源程序和目标程序，源语言和目标语言

- 前者是源代码写的程序，后者是翻译生成的程序。“语言”即所使用的语言。

#### 9-mips指令集

- mips是一种risc指令集。即microcomputer without interlocked pipeline stages.

#### 10-gcc编译过程

`hello.c`为例

- （高级语言源程序）预处理：对“#”定义的宏进行预先处理，包括把头文件嵌入等操作，生成`hello.i`。它仍是高级语言源程序。
- （汇编语言源程序）编译：对`hello.i`进行编译，生成汇编语言源程序`hello.s`。
- （可重定位目标程序）汇编：对`hello.s`进行汇编，生成机器语言的可重定位目标程序（relocatable object file） `hello.o`
- （可执行目标程序）链接：把`hello.o`和其他文件例如`printf.o`进行合并，生成可执行文件`hello.out`
  - 可执行文件又称可执行目标程序。可执行目标程序和可重定位目标程序的区别是前者是可执行的，而后者需要经过链接。

#### 11-读入键盘字符、输出字符到屏幕

- 键盘字符送到了CPU的寄存器中，随后送到主存中（输入缓冲区）
- 数据在送上总线之前，都要**先缓存**在存储部件（不是存储器）中。
  - 因此，在端口中，一般都有数据缓冲。

#### 12-南桥北桥

- 北桥芯片负责处理高速部件的通信，例如RAM
- 南桥芯片负责处理IO总线通信，例如外部设备、硬盘等

#### 12-端口

- 数据缓冲寄存器、命令字寄存器、状态字寄存器
- 端口可以进行独立编址，也可进行存储器映射编址。前者是自己一套IO地址空间，后者是把内存地址的一部分拿出来给IO编址。

#### 13-操作系统

- **操作系统是对计算机底层结构和硬件的一种抽象**

#### 13-计算机体系结构（指令集体系结构，ISA）

- Instruction Set Architecture
- 即计算机硬件和软件之间的交界面，软硬件接口
- 是软件对计算机硬件的感知方式
- ISA规定了一套指令集，即计算机机器语言的一套**设计规范**。例如Intel x86 ISA下有很多款CPU，但是由于使用了相同的ISA，所以在i9-9900k上跑的程序在上也能在AMD 3900X上跑。
- **ISA是整个计算机系统的核心。**ISA集中体现了硬件的特性，软件在ISA上跑。

#### 14-微体系架构（微架构）

- 一套ISA的**具体实现**就是这个ISA的微体系架构。
- 例如加法器可以使用串行进位，也可使用超前进位。

#### 14-高级语言`翻译`程序的前端和后端

- 高级语言程序的编译可以理解为语法分析、语义分析、中间代码生成、中间代码优化、目标代码生成、目标代码优化。
- 把中间代码生成**及其**之前的操作称为前端，之后的操作称为后端。
- 可以理解为：前端是检查ASCII写的程序并转化为汇编，后端是优化汇编并汇编成为目标程序。

#### 14-未定义行为和未确定行为

- undefined behavior：例如C90规定：在printf中使用错误的类型描述符就是未定义行为。它会导致每次执行的结果都不一样，或者在不同的微架构下执行结果都不一样。（即玄学行为）
  - 未定义行为即官方明确表示“我们不保证这么写他能跑”。
  - 原因：gcc明确给出了警告：这么写，**我们也不保证**他能跑出什么结果来。
- unspecified behavior：例如C对char到底是unsigned还是signed没有作出要求，所以在不同微架构下的gcc可能会对这个char给出不一样的解释，导致在不同微架构下，其执行结果不同。
  - 未确定行为即未明确给出规定的，模棱两可的。
  - 原因：gcc**没有强制规定**char属于什么类型，于是不同gcc的实现对他的处理有一定差异。

#### 15-ABI接口和API接口

- ABI接口可以类比API接口，但前者的层次非常低，包含了和硬件相关的接口，但是后者只是高层次的库之间的接口而已。
- ABI接口是在给定的ISA、给定的OS下，规定的及其级别的目标代码层接口。
  - ABI规定了诸如OS的系统调用、可执行文件格式、寄存器使用约定、内存地址划分等规范。因此，它不仅取决于ISA，还取决于OS。
  - 可以想象，如果在某ABI下编译好的程序，拿到另一台有相同ABI的电脑上跑，是可以正常跑的。

#### 16-计算机软件分类

- 系统软件
  - 包括OS、DBMS、Compiler、实用程序（例如KDE Plasma）
  - OS对硬件进行管理监视，对软件提供环境，对用户提供界面
  - 语言处理程序负责提供编程环境、装入运行环境等

#### 16-计算机用户分类

- 最终用户、系统管理员、应用程序员、系统程序员

#### 17-什么是透明

- 一种客观存在的东西，在某个**角度来看好像**不存在一样

#### 17-几种透明虚拟机

- 机器语言程序员看到的机器是ISA以上的部分，以下的部分透明了，称为机器语言虚拟机。
- 系统程序员看到的机器是装备了OS的机器，看到的是OS以上的部分，以下的部分透明了，称为操作系统虚拟机。
- 以此类推，还与汇编语言虚拟机、高级语言虚拟机。

#### 18-衡量计算机系统性能的定义

- 吞吐率：单位时间完成的工作数量
- 响应时间：从作业提交到给出相应（或作业完成）经过的时间
- CPI：一条指令执行所需的时钟周期数，一般采用`平均CPI`。对于一段给定的程序，可以求**针对**这段程序的平均CPI，即该程序的`综合CPI`（程序总指令数除以程序花费的总时钟周期数）。

#### 19-用户视角下的CPU时间（如何衡量计算机的好坏）

- 分为系统CPU时间（操作系统各操作占用的时间）、用户CPU时间（用户程序所占用的时间，**是用户体验的部分**）、其他CPU时间（例如等待IO时间、其他用户查程序占用的时间）。
- **衡量计算机性能好坏，往往通过用户CPU时间来衡量**。计算机的性能可以看做是用户CPU时间的**倒数**，也就是执行这一个用户程序需要多少用户CPU时间，该时间越短说明程序执行速度越快。
- 用户CPU时间=`CPI*这段程序的指令数*时钟周期宽度`
  - 可见，计算机的速度由CPI、指令条数、主频共同决定。他们互相制约，共同影响计算机的性能。

#### 21-MIPS法、Gibson混合法、FLOPS法

- Gibson混合法（对一条指令所需执行时间进行加权平均）：第i种指令的占比是wi，其所用时间是ti，则sigma(wi*ti)就是计算机**一条指令**的平均执行时间。
  - 如果时间单位是节拍，那么这就是CPI。
  - 如果时间单位是s，那么对他取倒数就是MIPS。
- 峰值MIPS，相对MIPS（P21）

#### 22-benchmark程序（基准程序）

- 基准程序是一种小程序，在不同电脑上运行，比较其执行时间，以对比出电脑性能的差异。
- 不排除厂商对基准程序中的瓶颈指令编写特定的编译器进行优化，以得出离谱的跑分的情况。（根据阿姆达尔 Amdahl 定律）。

#### 23-阿姆达尔定律 Amdahl's Law

- 对计算机系统的硬件或软件部分进行改进带来的性能提升程度**取决于该部分被使用的频率或占总执行时间的比例**。
- 定律的两种公式（P23）和例题
- 极限加速比：如果仅对某关键部分进行改进，而不去考虑其他部分，那么这种改进带来的性能提升是有上限的，例如P24例子，你怎么改进都不可能让性能提升5倍。
- 如果仅对使用较少的部分进行改进，带来的性能提升可能趋近于0.

