 

#### 什么是文件系统？

- 对于用户而言，文件系统的功能是组织成目录结构，实现按名存取与操作，并提供共享和保护功能。
- 对于OS而言，完成IO，完成文件逻辑和物理的变换，更高效地组织文件在磁盘上的存放，并提供好的访问调度算法提升性能。

#### HAL层？

Hardware Abstract Layer。OS只需要调用HAL的上层接口对硬件进行操作即可。这样，就算硬件改变，只需要修改HAL的下层接口，与OS无关。这样OS就可以更好地移植。

#### 存出一个文件时，如果当前磁道存不下了，是存到其他磁道，还是存到其他盘面的同一磁道？

- 存文件要遵循尽量保持同一柱面的原则。因为寻道花费的时间远大于旋转时间和传输时间。

#### 为什么使用系统API，而不直接使用系统调用？似乎后者更高效。

- 因为这样更具有移植性。
- 系统调用过于复杂，一般程序员难以使用。
- 但是系统调用如果不考虑上述两点，确实更加高效，因为前者被封装了。

#### 系统调用如何传递参数

- 寄存器立即数
  - 用户程序把参数写到寄存器里面即可
- 寄存器直接寻址
  - 用户程序把参数放入内存，把地址写入寄存器即可；OS直接寻址即可拿到
- 压栈
  - 用户程序把参数压入栈，OS从栈顶上弹即可拿到

#### 执行系统调用的步骤？

1. 执行陷阱（访管中断）
2. 传参数
3. 进入中断服务程序

#### 短程调度和长程调度的比较？

- 短程调度触发频繁，目的是提升CPU的利用率和系统吞吐率。
- 长程调度触发很不频繁，且在PC操作系统上少见。目的是通过协调IO-bound和CPU-bound进程的调度来提升系统并发度、提升CPU、IO设备的利用率。

#### MMU是什么？

将逻辑地址映射到物理地址。（注意这里的物理地址指的是**内存的**物理地址）

#### 内存中存放的打开文件三级结构？

- U区-全局打开文件表-aFCB表
- U区存放当前进程的打开的文件。在U区内的索引即fd。
- 全局打开文件表（包括文件名、读写指针等）指向aFCB表。
- aFCB中的引用数字段表明有多少个全局打开文件表项指向他；全局打开文件表的引用数字段表明有多少个U区表项指向他。
- 一个进程fork了一个进程，那么因为需要继承打开的文件，但是为了效率又不需要重复打开文件，这个时候的选择是：复制U区。
  - 复制了U区，意味着系统打开文件表中的该U区涉及的表项都被重复指向了一次，于是这些表项的引用数都+1.
  - 也就意味着这两个进程要共享读写指针（因为读写指针在系统打开文件表项中且只有一份），而以写为例，每次写都会让写指针+1（这是原子操作），所以如果两个进程同时输出a、b，那么文件里可以是ab或ba。
  - 因为fork之后，系统打开文件表中的对应表项没有被fork，所以aFCB中的引用数不会变。
  - 好处：当关闭一个文件，只有引用数减少到0，才会真正从U区中移除。于是aFCB中的引用数才会-1。
- 如何增加aFCB中的引用数？再打开一遍这个文件即可。因为这样会再在系统打开文件表中创建表项，然后指向它。
  - 好处：当移除系统打开文件表中的一个表项，可能不会影响aFCB，而只是让aFCB中这一表项的引用数-1。只有引用数减少到0，才会真正从aFCB中移除。

#### signal

- signal是linux中的软中断信号。PCB中有一些软中断信号位，当它接收到一个对应的信号，就把对应的位置1.
- 因为signal实际上是软中断，这进一步说明了OS是依靠中断运作的。因为进程之间的通信，signal也是一种方式。

#### 容易忽略的子进程继承父进程的特点

- 继承打开文件表（U区）
- 继承**信号处理函数**